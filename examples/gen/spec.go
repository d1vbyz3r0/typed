// Code generated by typed. DO NOT EDIT
package main

import (
	"fmt"
	"github.com/d1vbyz3r0/typed"
	"github.com/d1vbyz3r0/typed/examples/dto"
	"github.com/d1vbyz3r0/typed/examples/server"
	"github.com/d1vbyz3r0/typed/handlers"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3gen"
	"github.com/labstack/echo/v4"
	"log/slog"
	"os"
)

var UsedTypes = map[string]any{
	"dto.Form":           new(dto.Form),
	"dto.FormUploadResp": new(dto.FormUploadResp),
	"dto.Status":         new(dto.Status),
	"dto.User":           new(dto.User),
	"string":             new(string),
	"echo.Map":           new(echo.Map),
}

var Enums = map[string][]any{
	"dto.Status": {
		"active",
		"inactive",
	},
}

var Spec = &openapi3.T{
	OpenAPI: "3.0.0",
	Info: &openapi3.Info{
		Title:   "Example api",
		Version: "0.0.1",
	},
	Servers: []*openapi3.Server{
		{
			URL: "http://localhost:8080",
		},
	},
	Components: &openapi3.Components{
		Schemas:         make(openapi3.Schemas),
		SecuritySchemes: make(openapi3.SecuritySchemes),
	},
}

type GenerateOpts struct {
	Generator      *openapi3gen.Generator
	Routes         []handlers.EchoRoute
	UseTags        bool
	ApiPrefix      string
	SearchPatterns []handlers.SearchPattern
	Concurrency    int
}

func Generate(opts GenerateOpts) error {
	finder, err := handlers.NewFinder()
	if err != nil {
		return fmt.Errorf("create handlers finder: %w", err)
	}

	err = finder.Find(opts.SearchPatterns, handlers.WithConcurrency(opts.Concurrency))
	if err != nil {
		return fmt.Errorf("run finder: %w", err)
	}

	matchedHandlers := finder.Match(opts.Routes)
	for _, handler := range matchedHandlers {
		operation := openapi3.NewOperation()
		operation.Description = handler.Description()
		typed.AddPathParams(operation, handler, opts.Generator, UsedTypes)
		typed.AddQueryParams(operation, handler, opts.Generator, UsedTypes)
		typed.AddRequestBody(operation, handler, opts.Generator, Spec.Components.Schemas, UsedTypes)
		typed.AddResponses(operation, handler, opts.Generator, Spec.Components.Schemas, UsedTypes)
		typed.AddOperationId(operation, handler)
		if opts.UseTags {
			err = typed.TagOperation(operation, handler.Path(), opts.ApiPrefix)
			if err != nil {
				slog.Error("tag operation", "error", err)
				continue
			}
		}

		typed.RunHandlerHooks(Spec, operation, handler)
		Spec.AddOperation(handler.Path(), handler.Method(), operation)
	}

	return nil
}

func main() {
	const (
		apiPrefix = "/api/v1"
		useTags   = true
	)

	typed.RegisterCustomizer(typed.NewEnumsCustomizer(Enums))

	g := openapi3gen.NewGenerator(
		openapi3gen.UseAllExportedFields(),
		openapi3gen.CreateComponentSchemas(openapi3gen.ExportComponentSchemasOptions{
			ExportComponentSchemas: true,
			ExportTopLevelSchema:   true,
			ExportGenerics:         false,
		}),
		openapi3gen.SchemaCustomizer(typed.Customizer),
		openapi3gen.CreateTypeNameGenerator(typed.TypeNameGenerator),
	)

	err := typed.GenerateRefs(g, Spec.Components.Schemas, UsedTypes)
	if err != nil {
		slog.Error("generate refs for type registry", "error", err)
		os.Exit(1)
	}

	var routes []handlers.EchoRoute
	routesProvider := server.NewBuilder()
	routesProvider.OnRouteAdded(func(
		host string,
		route echo.Route,
		handler echo.HandlerFunc,
		middleware []echo.MiddlewareFunc,
	) {
		routes = append(routes, handlers.EchoRoute{
			Route:       route,
			Middlewares: middleware,
		})
	})
	routesProvider.ProvideRoutes()

	opts := GenerateOpts{
		Generator: g,
		Routes:    routes,
		UseTags:   useTags,
		ApiPrefix: apiPrefix,
		SearchPatterns: []handlers.SearchPattern{
			{
				Path:      ".",
				Recursive: false,
			},
		},
		Concurrency: 5,
	}

	err = Generate(opts)
	if err != nil {
		slog.Error("generate spec", "error", err)
		os.Exit(1)
	}

	err = typed.SaveSpec(Spec, "../gen/example.yaml")
	if err != nil {
		slog.Error("save spec", "error", err)
		os.Exit(1)
	}
}
