// Code generated by typed. DO NOT EDIT
package {{- if .GenerateLib }}{{ .LibPkg }}{{- else }} main {{- end}}

import (
    "github.com/d1vbyz3r0/typed"
    "github.com/d1vbyz3r0/typed/handlers"
    "github.com/getkin/kin-openapi/openapi3"
    "github.com/getkin/kin-openapi/openapi3gen"
    "github.com/labstack/echo/v4"
    "reflect"
	"log/slog"
{{- range .Imports}}
    "{{.}}"
{{- end}}
)

const (
{{- if ne .ApiPrefix nil }}
    apiPrefix = "{{ .ApiPrefix }}"
    useTags   = true
{{- else }}
    apiPrefix = ""
    useTags   = false
{{- end }}
)

var usedTypes = map[string]any{
    {{- range .Types}}
    "{{.}}": new({{.}}),
    {{- end}}
}

var enums = map[string][]any{
    {{- range $type, $values := .Enums }}
    "{{$type}}": {
        {{- range $i, $val := $values }}
        {{ printf "%#v" $val }},
        {{- end }},
    },
    {{- end }}
}

var spec = &openapi3.T{
    OpenAPI: "3.0.0",
    Info: &openapi3.Info{
        Title:   "{{ .Title }}",
        Version: "{{ .Version }}",
    },
    Servers: []*openapi3.Server{
		{{- range $i, $server := .Servers }}
        {
            URL: "{{ $server.Url }}",
        },
		{{- end}}
    },
    Components: &openapi3.Components{
        Schemas:         make(openapi3.Schemas),
        SecuritySchemes: make(openapi3.SecuritySchemes),
    },
}

var routes []handlers.EchoRoute

func onRouteAdded(
        host string,
        route echo.Route,
        handler echo.HandlerFunc,
        middleware []echo.MiddlewareFunc,
) {
    routes = append(routes, handlers.EchoRoute{
        Route:       route,
        Middlewares: middleware,
    })
}

func Generate() {
    g := openapi3gen.NewGenerator(
        openapi3gen.UseAllExportedFields(),
        openapi3gen.CreateComponentSchemas(openapi3gen.ExportComponentSchemasOptions{
            ExportComponentSchemas: true,
            ExportTopLevelSchema:   true,
            ExportGenerics:         false,
        }),
        openapi3gen.SchemaCustomizer(typed.Customizer),
        openapi3gen.CreateTypeNameGenerator(func(t reflect.Type) string {
            return t.String()
        }),
    )

    typed.RegisterCustomizer(typed.NewEnumsCustomizer(enums))
    {{- range .HandlerProcessingHooks }}
	typed.RegisterHandlerProcessingHook({{.}})
    {{- end }}

    routesProvider := {{ .RoutesProviderCtor }}
	routesProvider.OnRouteAdded(onRouteAdded)
    routesProvider.ProvideRoutes()

    finder, err := handlers.NewFinder()
    if err != nil {
        slog.Error("create handlers finder", "error", err)
		return
    }

    err = finder.Find([]handlers.SearchPattern{
        {{- range .HandlersPkgs}}
        {
            Path: "{{ .Path }}",
            Recursive: {{ .Recursive }},
        }
        {{- end}},
    })
    if err != nil {
		slog.Error("run finder", "error", err)
        return
    }

    matchedHandlers := finder.Match(routes)
    for _, handler := range matchedHandlers {
        operation := openapi3.NewOperation()
        operation.Description = handler.Description()
        typed.AddPathParams(operation, handler, g, usedTypes)
        typed.AddQueryParams(operation, handler, g, usedTypes)
        typed.AddRequestBody(operation, handler, g, spec.Components.Schemas, usedTypes)
        typed.AddOperationId(operation, handler)
        if useTags {
            typed.TagOperation(operation, handler.Path(), apiPrefix)
        }

		typed.RunHandlerHooks(spec, operation, handler)
        spec.AddOperation(handler.Path(), handler.Method(), operation)
    }
}

{{- if not .GenerateLib }}
func main() {
    Generate()
	err := typed.SaveSpec(spec, "{{.SpecPath}}")
    if err != nil {
		slog.Error("save spec", "error", err)
        return
	}
}
{{- end }}