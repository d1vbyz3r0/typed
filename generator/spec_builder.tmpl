// Code generated by typed. DO NOT EDIT.
package main

import (
    "fmt"
    "github.com/getkin/kin-openapi/openapi3"
    "github.com/getkin/kin-openapi/openapi3gen"
	"reflect"
    "log"
    "mime/multipart"
    "github.com/d1vbyz3r0/typed/generator"
	"github.com/labstack/echo/v4"
	"github.com/d1vbyz3r0/typed"
	"{{ .RoutesProviderPkg }}"
    {{- range .Imports}}
    "{{.}}"
    {{- end}}
)

const (
	bearerAuthScheme = "bearerAuth"
    {{- if ne .ApiPrefix nil }}
    apiPrefix = "{{ .ApiPrefix }}"
	useTags = true
	{{- else }}
    apiPrefix = ""
    useTags = false
	{{- end }}
)

var (
	jwtSecurityRequirement =  openapi3.NewSecurityRequirements().With(openapi3.SecurityRequirement{
        bearerAuthScheme: []string{},
    })

	registry = map[string]any{
        {{- range $name, $type := .Types}}
        "{{$name}}": new({{$type}}),
        {{- end}}
    }

    enums = map[string][]any{
    {{- range $type, $values := .Enums }}
    	"{{$type}}": {
    		{{- range $i, $val := $values }}
    			{{- if $i}}, {{ end -}}{{ printf "%#v" $val }}
    		{{- end }},
    	},
    {{- end }}
    }

    openapiGen = openapi3gen.NewGenerator(
        openapi3gen.UseAllExportedFields(),
        openapi3gen.CreateComponentSchemas(openapi3gen.ExportComponentSchemasOptions{
            ExportComponentSchemas: true,
            ExportTopLevelSchema:   true,
            ExportGenerics:         false,
        }),
        openapi3gen.SchemaCustomizer(customizer),
    )

    spec = &openapi3.T{
        OpenAPI: "3.0.0",
        Info: &openapi3.Info{
            Title:   "{{ .Title }}",
            Version: "{{ .Version }}",
        },
        Servers: []*openapi3.Server{
            {
                URL: "{{ .ServerUrl }}",
            },
        },
        Components: &openapi3.Components{
            Schemas: make(openapi3.Schemas),
            SecuritySchemes: make(openapi3.SecuritySchemes),
        },
    }

    routes []*echo.Route
	protectedRoutes = make(map[string]struct{})
)


func addJwtAuthSchema() {
	if _, ok := spec.Components.Schemas[bearerAuthScheme]; ok {
		return
    }

    spec.Components.SecuritySchemes[bearerAuthScheme] = &openapi3.SecuritySchemeRef{
        Value: &openapi3.SecurityScheme{
            Type: "http",
            Scheme: "bearer",
            BearerFormat: "JWT",
        },
    }
}

func isProtected(route string) bool {
	_, protected := protectedRoutes[route]
	return protected
}

func onRouteAdded(_ string, route echo.Route, _ echo.HandlerFunc, middlewares []echo.MiddlewareFunc) {
	routes = append(routes, &route)
	for _, mw := range middlewares {
		if typed.IsJwtMiddleware(mw) {
			addJwtAuthSchema()
			protectedRoutes[route.Path] = struct{}{}
        }
    }
}

func customizer(name string, t reflect.Type, tag reflect.StructTag, schema *openapi3.Schema) error {
    if t == reflect.TypeOf(multipart.FileHeader{}) {
        schema.Type = &openapi3.Types{openapi3.TypeString}
        schema.Format = "binary"
    }

    if values, ok := enums[t.Name()]; ok {
    		schema.Enum = make([]interface{}, len(values))
    		for i, v := range values {
    			schema.Enum[i] = v
    		}
    	}

    return nil
}

func main() {
	var rp typed.RoutesProvider = {{ .RoutesProviderCtor }}
	rp.OnRouteAdded(onRouteAdded)
	rp.ProvideRoutes()

    ra := generator.NewRouteAnalyzer()
    ha := generator.NewHandlerAnalyzer([]generator.PkgInfo{
		{{- range .HandlersPkgs}}
		{
			Path: "{{ .Path }}",
			Recursive: {{ .Recursive }},
        }
		{{- end}},
    })

    err := ra.CollectRoutes(routes)
    if err != nil {
        log.Fatal(err)
    }

    err = ha.DiscoverHandlers()
    if err != nil {
        log.Fatal(err)
    }

    ra.MatchHandlers(ha.Handlers())

    for _, instance := range registry {
        _, err := openapiGen.NewSchemaRefForValue(instance, spec.Components.Schemas)
        if err != nil {
            log.Fatal(err)
        }
    }

    for _, route := range ra.Routes() {
        if route.Handler != nil {
			for _, r := range route.Handler.Responses {
				if r.IsMap {
					// TODO: need to deal with types...
                    mapKey := fmt.Sprintf("map[%s]%s", r.KeyType, r.ValueType)
					registry[mapKey] = new(map[string]any)
                }
            }

			operation := openapi3.NewOperation()
            typed.AddPathParams(operation, route)
            typed.AddRequestBody(operation, route, openapiGen, registry)
            typed.AddResponses(operation, route, openapiGen, registry)
            typed.AddQueryParams(operation, route)
            typed.AddOperationId(operation, route)

			if isProtected(route.Path) {
                operation.Security = jwtSecurityRequirement
            }

			if useTags {
				err := typed.TagOperation(operation, route.Path, apiPrefix)
				if err != nil {
					log.Printf("[ERROR] failed to tag operation: %v", err)
                }
            }

            route.Path = typed.NormalizePathParams(route.Path)
			spec.AddOperation(route.Path, route.Method, operation)
        }
    }

	typed.SaveSpec(spec, "{{ .SpecPath }}")
}
