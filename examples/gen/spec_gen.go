// Code generated by typed. DO NOT EDIT
package main

import (
	"github.com/d1vbyz3r0/typed"
	"github.com/d1vbyz3r0/typed/examples/api"
	"github.com/d1vbyz3r0/typed/examples/api/dto"
	"github.com/d1vbyz3r0/typed/handlers"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/getkin/kin-openapi/openapi3gen"
	"github.com/labstack/echo/v4"
	"log/slog"
	"reflect"
)

const (
	apiPrefix = "/api/v1"
	useTags   = true
)

var usedTypes = map[string]any{
	"dto.User":              new(dto.User),
	"dto.UserRole":          new(dto.UserRole),
	"dto.UsersFilter":       new(dto.UsersFilter),
	"[]dto.User":            new([]dto.User),
	"map[string][]dto.User": new(map[string][]dto.User),
	"dto.Error":             new(dto.Error),
	"dto.SortOrder":         new(dto.SortOrder),
}

var enums = map[string][]any{
	"dto.SortOrder": {
		"asc",
		"desc",
	},
	"dto.UserRole": {
		"user",
		"admin",
	},
}

var spec = &openapi3.T{
	OpenAPI: "3.0.0",
	Info: &openapi3.Info{
		Title:   "Example api",
		Version: "0.0.1",
	},
	Servers: []*openapi3.Server{
		{
			URL: "http://localhost:8080",
		},
	},
	Components: &openapi3.Components{
		Schemas:         make(openapi3.Schemas),
		SecuritySchemes: make(openapi3.SecuritySchemes),
	},
}

var routes []handlers.EchoRoute

func onRouteAdded(
	host string,
	route echo.Route,
	handler echo.HandlerFunc,
	middleware []echo.MiddlewareFunc,
) {
	routes = append(routes, handlers.EchoRoute{
		Route:       route,
		Middlewares: middleware,
	})
}

func Generate() {
	g := openapi3gen.NewGenerator(
		openapi3gen.UseAllExportedFields(),
		openapi3gen.CreateComponentSchemas(openapi3gen.ExportComponentSchemasOptions{
			ExportComponentSchemas: true,
			ExportTopLevelSchema:   true,
			ExportGenerics:         false,
		}),
		openapi3gen.SchemaCustomizer(typed.Customizer),
		openapi3gen.CreateTypeNameGenerator(func(t reflect.Type) string {
			return t.String()
		}),
	)

	typed.RegisterCustomizer(typed.NewEnumsCustomizer(enums))

	routesProvider := api.NewServerBuilder()
	routesProvider.OnRouteAdded(onRouteAdded)
	routesProvider.ProvideRoutes()

	finder, err := handlers.NewFinder()
	if err != nil {
		slog.Error("create handlers finder", "error", err)
		return
	}

	err = finder.Find([]handlers.SearchPattern{
		{
			Path:      "./handlers",
			Recursive: true,
		},
	})
	if err != nil {
		slog.Error("run finder", "error", err)
		return
	}

	matchedHandlers := finder.Match(routes)
	for _, handler := range matchedHandlers {
		operation := openapi3.NewOperation()
		operation.Description = handler.Description()
		typed.AddPathParams(operation, handler, g, usedTypes)
		typed.AddQueryParams(operation, handler, g, usedTypes)
		typed.AddRequestBody(operation, handler, g, spec.Components.Schemas, usedTypes)
		typed.AddResponses(operation, handler, g, spec.Components.Schemas, usedTypes)
		typed.AddOperationId(operation, handler)
		if useTags {
			err = typed.TagOperation(operation, handler.Path(), apiPrefix)
			if err != nil {
				slog.Error("tag operation", "error", err)
				continue
			}
		}

		typed.RunHandlerHooks(spec, operation, handler)
		spec.AddOperation(handler.Path(), handler.Method(), operation)
	}
}
func main() {
	Generate()
	err := typed.SaveSpec(spec, "../gen/example.yaml")
	if err != nil {
		slog.Error("save spec", "error", err)
		return
	}
}
