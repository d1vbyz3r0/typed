// Code generated by typed. DO NOT EDIT
package {{- if .GenerateLib }}{{ .LibPkg }}{{- else }} main {{- end}}

import (
    "github.com/d1vbyz3r0/typed"
    "github.com/d1vbyz3r0/typed/handlers"
    "github.com/getkin/kin-openapi/openapi3"
    "github.com/getkin/kin-openapi/openapi3gen"
    "github.com/labstack/echo/v4"
    "log/slog"
    "os"
	"fmt"
{{- range .Imports}}
    "{{.}}"
{{- end}}
)

var UsedTypes = map[string]any{
    {{- range .Types}}
    "{{.}}": new({{.}}),
    {{- end}}
}

var Enums = map[string][]any{
    {{- range $type, $values := .Enums }}
    "{{$type}}": {
        {{- range $i, $val := $values }}
        {{ printf "%#v" $val }},
        {{- end }}
    },
    {{- end }}
}

var Spec = &openapi3.T{
    OpenAPI: "3.0.0",
    Info: &openapi3.Info{
        Title:   "{{ .Title }}",
        Version: "{{ .Version }}",
    },
    Servers: []*openapi3.Server{
        {{- range $i, $server := .Servers }}
        {
            URL: "{{ $server.Url }}",
        },
        {{- end}}
    },
    Components: &openapi3.Components{
        Schemas:         make(openapi3.Schemas),
        SecuritySchemes: make(openapi3.SecuritySchemes),
    },
}

type GenerateOpts struct {
    Generator      *openapi3gen.Generator
    Routes         []handlers.EchoRoute
    UseTags        bool
    ApiPrefix      string
    SearchPatterns []handlers.SearchPattern
}

func Generate(opts GenerateOpts) error {
    finder, err := handlers.NewFinder()
    if err != nil {
        return fmt.Errorf("create handlers finder: %w", err)
    }

    err = finder.Find(opts.SearchPatterns)
    if err != nil {
		return fmt.Errorf("run finder: %w", err)
    }

    matchedHandlers := finder.Match(opts.Routes)
    for _, handler := range matchedHandlers {
        operation := openapi3.NewOperation()
        operation.Description = handler.Description()
        typed.AddPathParams(operation, handler, opts.Generator, UsedTypes)
        typed.AddQueryParams(operation, handler, opts.Generator, UsedTypes)
        typed.AddRequestBody(operation, handler, opts.Generator, Spec.Components.Schemas, UsedTypes)
        typed.AddResponses(operation, handler, opts.Generator, Spec.Components.Schemas, UsedTypes)
        typed.AddOperationId(operation, handler)
        if opts.UseTags {
            err = typed.TagOperation(operation, handler.Path(), opts.ApiPrefix)
            if err != nil {
                slog.Error("tag operation", "error", err)
                continue
            }
        }

        typed.RunHandlerHooks(Spec, operation, handler)
        Spec.AddOperation(handler.Path(), handler.Method(), operation)
    }

	return nil
}

{{- if not .GenerateLib }}
func main() {
    const (
    {{- if ne .ApiPrefix nil }}
        apiPrefix = "{{ .ApiPrefix }}"
        useTags   = true
    {{- else }}
        apiPrefix = ""
        useTags   = false
    {{- end }}
    )

    typed.RegisterCustomizer(typed.NewEnumsCustomizer(Enums))
    {{- range .HandlerProcessingHooks }}
    typed.RegisterHandlerProcessingHook({{.}})
    {{- end }}

    g := openapi3gen.NewGenerator(
        openapi3gen.UseAllExportedFields(),
        openapi3gen.CreateComponentSchemas(openapi3gen.ExportComponentSchemasOptions{
            ExportComponentSchemas: true,
            ExportTopLevelSchema:   true,
            ExportGenerics:         false,
        }),
        openapi3gen.SchemaCustomizer(typed.Customizer),
        openapi3gen.CreateTypeNameGenerator(typed.GenerateTypeName),
    )

    err := typed.GenerateRefs(g, Spec.Components.Schemas, UsedTypes)
    if err != nil {
        slog.Error("generate refs for type registry", "error", err)
        os.Exit(1)
    }

    var routes []handlers.EchoRoute
    routesProvider := {{ .RoutesProviderCtor }}
    routesProvider.OnRouteAdded(func(
            host string,
            route echo.Route,
            handler echo.HandlerFunc,
            middleware []echo.MiddlewareFunc,
    ) {
        routes = append(routes, handlers.EchoRoute{
            Route:       route,
            Middlewares: middleware,
        })
    })
    routesProvider.ProvideRoutes()

    opts := GenerateOpts{
        Generator: g,
        Routes:    routes,
        UseTags:   useTags,
        ApiPrefix: apiPrefix,
        SearchPatterns: []handlers.SearchPattern{
            {{- range .HandlersPkgs}}
            {
                Path: "{{ .Path }}",
                Recursive: {{ .Recursive }},
            },
            {{- end}}
        },
    }

	err = Generate(opts)
    if err != nil {
		slog.Error("generate spec", "error", err)
		os.Exit(1)
    }

    err = typed.SaveSpec(Spec, "{{.SpecPath}}")
    if err != nil {
        slog.Error("save spec", "error", err)
        os.Exit(1)
    }
}
{{- end }}